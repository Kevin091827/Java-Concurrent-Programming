package com.kevin.demo.lock;

import java.util.Collection;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;

/**
 * @Auther: Kevin
 * @Date:
 * @ClassName:QueueApi
 * @Description: TODO
 */
public class QueueApi {

//--------------------------------------------------------
//    //获取当前同步状态
//    int getState();
//
//    //设置当前同步状态
//    boolean setState(int newState);
//
//    //设置当前状态
//    boolean compareAndSetState(int expect,int update);
//--------------------------------------------------------

//--------------------------------------------------------
//    //独占式获取同步状态
//    protected boolean tryAcquire(int arg);
//
//    //独占式释放同步状态
//    protected boolean tryRelease(int arg);
//
//    //共享式获取同步状态
//    protected int tryAcquireShared(int arg);
//
//    //共享式释放同步状态
//    protected boolean tryReleaseShared(int arg);
//
//    //判断当前同步器是否在独占模式下被当前线程占用
//    protected boolean isHeldExclusively();
//--------------------------------------------------------


// --------------------------------------------------------

//      //独占式获取同步状态
//     void acquire(int arg);
//
//    //独占式获取同步状态(可中断)
//    void acquireInterruptibly(int arg);
//
//    //独占式获取同步状态（超时获取）
//    boolean tryAcquireNanos(int arg,long nanos);
//
//    //共享式获取同步状态
//    void acquireShared(int arg);
//
//    //共享式获取同步状态(可中断)
//    void acquireSharedInterruptibly(int arg);
//
//    //共享式获取同步状态（超时获取）
//    boolean tryAcquireSharedNanos(int arg,long nanos);
//
//    //独占式释放同步状态
//    boolean release(int arg);
//
//    //共享式释放同步状态
//    boolean releaseShared(int arg);
//
//    //获取等待在同步队列上的线程集合
//    Collection<Thread> getQueuedThreads();
//--------------------------------------------------------
}
